{"meta":{"title":"博客","subtitle":null,"description":null,"author":"liumengjie","url":"http://yoursite.com/liumengjie2148.github.io"},"pages":[],"posts":[{"title":"给页面添加水印","slug":"给页面添加水印","date":"2020-12-23T06:54:00.000Z","updated":"2021-05-18T09:45:06.741Z","comments":true,"path":"2020/12/23/给页面添加水印/","link":"","permalink":"http://yoursite.com/liumengjie2148.github.io/2020/12/23/给页面添加水印/","excerpt":"","text":"给页面添加水印的两种方式： JS生成dom节点给页面添加水印可以JS生成一个DIV，设置绝对定位来做，水印一般都是斜着的，所以顺便给他旋转一下，同时需要取消这个div的点击事件，否则会影响页面交互。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132 // 生成水印节点watermark(settings = &#123;&#125;) &#123; // 默认设置 let options = &#123; text: 'xxx机构出品', width: 140, // 水印宽度 height: 78, // 水印高度 rows: 200, // 水印行数 cols: 4, // 水印列数 angle: 10 // 水印倾斜度数 x: 0, // 水印起始位置x轴坐标 y: 20, // 水印起始位置Y轴坐标 x_space: 80, // 水印x轴间隔 y_space: 80, // 水印y轴间隔 color: '#e0e0e0', // 水印字体颜色 alpha: 0.2, // 水印透明度 fontsize: '14px', // 水印字体大小 font: '微软雅黑', // 水印字体 &#125; options = &#123; ...options, ...settings &#125; const oTemp = document.createDocumentFragment() const printDom = document.getElementById('print-body') // 获取打印dom宽度 const pageWidth = printDom.offsetWidth // 获取打印dom宽度 const pageHeight = printDom.offsetHeight // 如果将水印列数设置为0，或水印列数设置过大，超过页面最大宽度，则重新计算水印列数和水印x轴间隔 const pageWidthCols = options.x + options.width * options.cols + options.x_space * (options.cols - 1) if ( options.cols === 0 || // eslint-disable-next-line radix parseInt(pageWidthCols) &gt; pageWidth ) &#123; const watermarkCols = (pageWidth - options.x + options.x_space) / (options.width + options.x_space) // eslint-disable-next-line radix options.cols = parseInt(watermarkCols) const watermarkXspace = (pageWidth - options.x - options.width * options.cols) / (options.cols - 1) // eslint-disable-next-line radix options.x_space = parseInt(watermarkXspace) &#125; const pageHeightCols = options.y + options.height * options.rows + options.y_space * (options.rows - 1) // 如果将水印行数设置为0，或水印行数设置过大，超过页面最大长度，则重新计算水印行数和水印y轴间隔 if ( options.rows === 0 || // eslint-disable-next-line radix parseInt(pageHeightCols) &gt; pageHeight ) &#123; const watermarkRows = (options.y_space + pageHeight - options.y) / (options.height + options.y_space) // eslint-disable-next-line radix options.rows = parseInt(watermarkRows) const watermarkYspace = (pageHeight - options.y - options.height * options.rows) / (options.rows - 1) // eslint-disable-next-line radix options.y_space = parseInt(watermarkYspace) &#125; let x let y for (let i = 0; i &lt; options.rows; i += 1) &#123; y = options.y + (options.y_space + options.height) * i for (let j = 0; j &lt; options.cols; j += 1) &#123; x = options.x + (options.width + options.x_space) * j const maskDiv = document.createElement('div') maskDiv.id = `maskDiv$&#123;i&#125;$&#123;j&#125;` maskDiv.className = 'maskDiv' maskDiv.innerText = options.text // 设置水印div倾斜显示 maskDiv.style.webkitTransform = `rotate(-$&#123;options.angle&#125;deg)` maskDiv.style.MozTransform = `rotate(-$&#123;options.angle&#125;deg)` maskDiv.style.msTransform = `rotate(-$&#123;options.angle&#125;deg)` maskDiv.style.OTransform = `rotate(-$&#123;options.angle&#125;deg)` maskDiv.style.transform = `rotate(-$&#123;options.angle&#125;deg)` maskDiv.style.visibility = '' maskDiv.style.position = 'absolute' maskDiv.style.left = `$&#123;x&#125;px` maskDiv.style.top = `$&#123;y&#125;px` maskDiv.style.overflow = 'hidden' maskDiv.style.zIndex = '1' // 让水印不遮挡页面的点击事件 maskDiv.style.pointerEvents = 'none' maskDiv.style.opacity = options.alpha maskDiv.style.fontSize = options.fontsize maskDiv.style.fontFamily = options.font maskDiv.style.color = options.color maskDiv.style.textAlign = 'center' maskDiv.style.width = `$&#123;options.width&#125;px` maskDiv.style.height = `$&#123;options.height&#125;px` maskDiv.style.lineHeight = `$&#123;options.height&#125;px` maskDiv.style.display = 'block' oTemp.appendChild(maskDiv) &#125; &#125; printDom.appendChild(oTemp)&#125; 每次生成水印时先清空上次生成的水印123456789101112this.removeWaterMark()const watermark = 'xxx机构'this.watermark(&#123; text: `$&#123;watermark&#125;出品` &#125;)// 删除水印节点removeWaterMark() &#123; const printDivDom = Array.from(document.getElementsByClassName('maskDiv')) const printDom = document.getElementById('print-body') printDivDom.forEach(item =&gt; &#123; printDom.removeChild(item) &#125;)&#125; 优点：打印时是有水印的缺点：打印预览和打印出来的水印字体样式比页面上的水印文字明显，影响页面正文阅读 基于canvas给页面添加水印canvas元素其实就是一个画布，我们可以很方便地绘制一些文字、线条、图形等，它也可以将一个img标签里渲染的图片画在画布上。 12345678910111213141516getWaterMarkImg(&#123;text, width, height, color, fontSize, alpha&#125;) &#123; const svgStr = `&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"$&#123;width&#125;px\" height=\"$&#123;height&#125;px\"&gt; &lt;text x=\"20%\" y=\"50%\" dy=\"12px\" text-anchor=\"start\" stroke=\"$&#123;color&#125;\" stroke-opacity=\"$&#123;alpha&#125;\" fill=\"none\" transform=\"rotate(-15, 120 120)\" font-weight=\"100\" font-size=\"$&#123;fontSize&#125;\" &gt; $&#123;text&#125; &lt;/text&gt; &lt;/svg&gt;` return `data:image/svg+xml;base64,$&#123;window.btoa(unescape(encodeURIComponent(svgStr)))&#125;`&#125; 12345678910111213const el = this.$refs.watermarkconst text = 'xxx机构出品'if (el &amp;&amp; text) &#123; const img = this.getWaterMarkImg(&#123; text, width: 300, height: 200, color: '#000000', fontsize: 14, alpha: 0.1 &#125;) el.style.background = `url('$&#123;img&#125;') repeat`&#125; 缺点：打印时是没有水印的，只限于页面查看时有水印 若要打印有水印的页面，可以让后台提供有水印的pdf文件链接来打印","categories":[],"tags":[]},{"title":"MacOS安装npm全局包遇到权限问题","slug":"MacOS安装npm全局包遇到权限问题","date":"2018-08-27T07:30:11.000Z","updated":"2020-12-23T03:11:07.961Z","comments":true,"path":"2018/08/27/MacOS安装npm全局包遇到权限问题/","link":"","permalink":"http://yoursite.com/liumengjie2148.github.io/2018/08/27/MacOS安装npm全局包遇到权限问题/","excerpt":"","text":"MacOS安装npm全局包遇到权限问题在MacOS上全局安装某个npm包时，会遇到如下问题： 1npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules 解决方案： 在安装命令前加上sudo,即执行命令 sudo npm install -g npm包名，会提示输入密码，输入本机开机密码即可获取权限安装。","categories":[],"tags":[]},{"title":"Echarts图表之formatter用法","slug":"Echarts之formatter用法","date":"2018-08-24T10:39:08.000Z","updated":"2020-12-23T03:11:07.942Z","comments":true,"path":"2018/08/24/Echarts之formatter用法/","link":"","permalink":"http://yoursite.com/liumengjie2148.github.io/2018/08/24/Echarts之formatter用法/","excerpt":"","text":"formatter 内容格式器，把一些不够人性化的内容通过某种处理让其变得人性化，便于用户更好地理解内容，支持字符串模板和回调函数两种形式 Echarts图表组件内的格式化常用的地方：1、 legend.formatter用来格式化图例文本。 示例： 123456// 使用字符串模板，模板变量为图例名称 &#123;name&#125;formatter: 'Legend &#123;name&#125;'// 使用回调函数formatter: function (name) &#123; return 'Legend ' + name;&#125; 2、 xAxis.axisLabel.formatter / yAxis.axisLabel.formatter刻度标签的内容格式器 示例: 123456789101112// 使用字符串模板，模板变量为刻度默认标签 &#123;value&#125;formatter: '&#123;value&#125; kg'// 使用函数模板，函数参数分别为刻度数值（类目），刻度的索引formatter: function (value, index) &#123; // 格式化成月/日，只在第一个刻度显示年份 var date = new Date(value); var texts = [(date.getMonth() + 1), date.getDate()]; if (index === 0) &#123; texts.unshift(date.getYear()); &#125; return texts.join('/');&#125; 3、 tooltip.formatter提示框浮层内容格式器 （1） 字符串模板 模板变量有 {a}, {b}，{c}，{d}，{e}，分别表示系列名，数据名，数据值等。 在 trigger 为 ‘axis’ 的时候，会有多个系列的数据，此时可以通过 {a0}, {a1}, {a2} 这种后面加索引的方式表示系列的索引。 不同图表类型下的 {a}，{b}，{c}，{d} 含义不一样。 其中变量{a}, {b}, {c}, {d}在不同图表类型下代表数据含义为： 折线（区域）图、柱状（条形）图、K线图 : {a}（系列名称），{b}（类目值），{c}（数值）, {d}（无） 散点图（气泡）图 : {a}（系列名称），{b}（数据名称），{c}（数值数组）, {d}（无） 地图 : {a}（系列名称），{b}（区域名称），{c}（合并数值）, {d}（无） 饼图、仪表盘、漏斗图: {a}（系列名称），{b}（数据项名称），{c}（数值）, {d}（百分比） 更多其它图表模板变量的含义可以见相应的图表的 label.formatter 配置项。 示例： 1formatter: '&#123;b0&#125;: &#123;c0&#125;&lt;br /&gt;&#123;b1&#125;: &#123;c1&#125;' (2) 回调函数 回调函数格式： (params: Object|Array, ticket: string, callback: (ticket: string, html: string)) =&gt; string第一个参数 params 是 formatter 需要的数据集。格式如下： 12345678910111213141516171819202122&#123; componentType: &apos;series&apos;, // 系列类型 seriesType: string, // 系列在传入的 option.series 中的 index seriesIndex: number, // 系列名称 seriesName: string, // 数据名，类目名 name: string, // 数据在传入的 data 数组中的 index dataIndex: number, // 传入的原始数据项 data: Object, // 传入的数据值 value: number|Array, // 数据图形的颜色 color: string, // 饼图的百分比 percent: number,&#125; 在 trigger 为 ‘axis’ 的时候，或者 tooltip 被 axisPointer 触发的时候，params 是多个系列的数据数组。其中每项内容格式同上，并且， 123456789101112131415161718192021[&#123; componentType: &apos;series&apos;, // 系列类型 seriesType: string, // 系列在传入的 option.series 中的 index seriesIndex: number, // 系列名称 seriesName: string, // 数据名，类目名 name: string, // 数据在传入的 data 数组中的 index dataIndex: number, // 传入的原始数据项 data: Object, // 传入的数据值 value: number|Array, // 数据图形的颜色 color: string,&#125;,...] 注： ECharts 2.x 使用数组表示各参数的方式不再支持。 第二个参数 ticket 是异步回调标识，配合第三个参数 callback 使用。 第三个参数 callback 是异步回调，在提示框浮层内容是异步获取的时候，可以通过 callback 传入上述的 ticket 和 html 更新提示框浮层内容。 示例： 123456formatter: function (params, ticket, callback) &#123; $.get('detail?name=' + params.name, function (content) &#123; callback(ticket, toHTML(content)); &#125;); return 'Loading';&#125; 4、 series[i]-*.label.formatter标签内容格式器，字符串模板与回调函数返回的字符串均支持用 \\n 换行。 字符串模板 模板变量有： {a}：系列名。 {b}：数据名。 {c}：数据值。 {@xxx}：数据中名为’xxx’的维度的值，如{@product}表示名为’product’` 的维度的值。 {@[n]}：数据中维度n的值，如{@[3]}` 表示维度 3 的值，从 0 开始计数。 示例： 1formatter: '&#123;b&#125;: &#123;@score&#125;' 回调函数 格式： 1(params: Object|Array) =&gt; string 参数 params 是 formatter 需要的单个数据集。格式如下： 1234567891011121314151617181920&#123; componentType: &apos;series&apos;, // 系列类型 seriesType: string, // 系列在传入的 option.series 中的 index seriesIndex: number, // 系列名称 seriesName: string, // 数据名，类目名 name: string, // 数据在传入的 data 数组中的 index dataIndex: number, // 传入的原始数据项 data: Object, // 传入的数据值 value: number|Array, // 数据图形的颜色 color: string,&#125;","categories":[],"tags":[]},{"title":"npm 私有仓库 install 使用方法","slug":"npm 私有仓库 install 使用方法","date":"2018-07-14T07:08:25.000Z","updated":"2020-12-23T03:11:07.950Z","comments":true,"path":"2018/07/14/npm 私有仓库 install 使用方法/","link":"","permalink":"http://yoursite.com/liumengjie2148.github.io/2018/07/14/npm 私有仓库 install 使用方法/","excerpt":"","text":"创建用户1npm adduser --registry=http://registry.npm.aibeike.com:7001 登录用户并指定 registry（源）和scope（作用域）123npm login --registry=http://registry.npm.aibeike.com:7001 --scope=@tal--registry # 私有仓库地址--scope # 作用域，当带有配置的作用域时，会到我们的私服上拉取npm包 npm包以后的命名会有作用域，规范 @scope/packageName 注意请不要把全局的 registry设置为http://registry.npm.aibeike.com:7001","categories":[],"tags":[]},{"title":"echarts使用笔记","slug":"echarts使用笔记","date":"2018-07-13T02:31:30.000Z","updated":"2020-12-23T03:11:07.934Z","comments":true,"path":"2018/07/13/echarts使用笔记/","link":"","permalink":"http://yoursite.com/liumengjie2148.github.io/2018/07/13/echarts使用笔记/","excerpt":"","text":"一、在webpack中使用EChartsnpm 安装 ECharts 使用下面的命令通过npm安装ECharts npm install echarts --save 引入ECharts 可以直接在项目代码中 require(&#39;echarts&#39;)来整体引入ECharts。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139var echarts = require('echarts');// 基于准备好的dom，初始化echarts实例var myChart = echarts.init(document.getElementById('main'));// 绘制图表myChart.setOption(&#123; tooltip: &#123; // 提示框 trigger: 'axis' &#125;, legend: &#123; top: 90, right: 8, itemWidth: 16, itemHeight: 12, orient: 'vertical', data: ['小学', '初中', '高中'] &#125;, toolbox: &#123; // 工具箱 right: 16, top: 0, itemGap: 16, // 工具栏 icon 每项之间的间隔。横向布局时为水平间隔，纵向布局时为纵向间隔。 feature: &#123; // 各个工具配置项 myTool1: &#123; show: true, title: '导出表格', icon: 'image://../../../../static/images/Excel-download@2x.png', onclick: () =&gt; &#123; downloadExl(this.exportData, '', this.elementId) &#125; &#125;, saveAsImage: &#123; title: '导出图片', type: 'png', excludeComponents: [ // 保存图表时忽略的工具组件,默认忽略工具栏 'toolbox' ], icon: 'image://../../../../static/images/Pic-download@2x.png' &#125; &#125; &#125;, xAxis: &#123; data: this.subList, axisLine: &#123;show: false&#125;, // 是否显示坐标轴轴线。 nameTextStyle: &#123;color: '#212121'&#125;, axisTick: &#123;show: false&#125; // 是否显示坐标轴刻度。 &#125;, yAxis: &#123; axisLine: &#123;show: false&#125;, axisTick: &#123;show: false&#125;, splitLine: &#123; // 坐标轴在 grid 区域中的分隔线 lineStyle: &#123;type: 'dashed'&#125; // 分隔线线的类型。 &#125; &#125;, series: [ &#123; name: '小学', type: 'bar', barWidth: 16, barGap: '80%', data: this.xiaoCnt, label: &#123; normal: &#123; show: true, position: 'top', rotate: 45 &#125; &#125;, itemStyle: &#123; normal: &#123; color: '#FFE066', label: &#123; show: true, textStyle: &#123; color: '#000' &#125; &#125; &#125; &#125; &#125;, &#123; name: '初中', type: 'bar', barWidth: 16, barGap: '80%', data: this.chuCnt, label: &#123; normal: &#123; show: true, position: 'top', rotate: 45 &#125; &#125;, itemStyle: &#123; normal: &#123; color: '#8CE99A', label: &#123; show: true, textStyle: &#123; color: '#000' &#125; &#125; &#125; &#125; &#125;, &#123; name: '高中', type: 'bar', barWidth: 16, barGap: '80%', data: this.gaoCnt, label: &#123; normal: &#123; show: true, position: 'top', rotate: 45 &#125; &#125;, itemStyle: &#123; normal: &#123; color: '#72C3FC', label: &#123; show: true, textStyle: &#123; color: '#000' &#125; &#125; &#125; &#125; &#125; ], // 控制边距 grid: &#123; left: 0, right: '8%', top: 30, bottom: 0, containLabel: true &#125;&#125;) 按需引入ECharts图表和组件 默认使用require(&#39;echarts&#39;)得到的是已经加载了所有图表和组件的ECharts包，在项目中，可以只按需引入需要的模块。 例如上面实例代码中只用到了柱状图、title、提示框、工具组件、图例组件，因此在引入的时候也只需要引入这些模块。 1234567// 引入ECharts 主模块var echarts = require('echarts/lib/echarts')require('echarts/lib/chart/bar') // 引入柱状图require('echarts/lib/component/tooltip') // 信息提示框组件require('echarts/lib/component/toolbox') // 引入工具组件require('echarts/lib/component/legend') // 引入图例组件require('echarts/lib/component/title') // title组件 可以按需引入的模块列表见 (https://github.com/ecomfe/echarts/blob/master/index.js) 二、图表的样式Echarts 提供了丰富的自定义配置选项，并且能够从全局、系列、数据3个层级去设置数据图形的样式。 使用Echarts实现下面这个南丁格尔图： 绘制南丁格尔图这次要画的是饼图，饼图主要是通过扇形的弧度表现不同类目的数据在总和中的占比，它的数据格式比柱状图更简单，只有一维的数值，不需要给类目。因为不在直角坐标系上，所以也不需要xAxis, yAxis。 12345678910111213141516myChart.setOption(&#123; series : [ &#123; name: '入库试题量', type: 'pie', radius: [0, '60%'], center: ['50%', '50%'], data:[ &#123;value: 7307, name: '录排订单'&#125;, &#123;value: 948, name: '改编订单'&#125;, &#123;value: 4064, name: 'Word订单'&#125;, &#123;value: 2711, name: '直接录入'&#125; ] &#125; ]&#125;) 上面的代码就能画出一个简单的饼图： 这里的data属性不像介绍ECharts引入方式时柱状图里那样每一项都是单个数值，而是一个包含 name 和 value属性的对象，ECharts中的数据项都是既可以只设成数值，也可以设成一个包含有名称、该数据图形的样式配置、标签配置的对象。具体见[data文档] (http://echarts.baidu.com/option.html#series-pie.data) ECharts 中的饼图通过设置 roseType 就可以显示成南丁格尔图。 1roseType: &apos;angle&apos; 南丁格尔图会通过半径表示数据的大小。 阴影的配置ECharts 中有一些通用的样式，诸如阴影、透明度、颜色、边框颜色、边框宽度等，这些样式一般都会在系列的 itemStyle 里设置。例如阴影的样式可以通过下面几个配置项设置： 123456itemStyle: &#123; shadowBlur: 200,// 阴影的大小 shadowOffsetX: 0,// 阴影水平方向上的偏移 shadowOffsetY: 0,// 阴影垂直方向上的偏移 shadowColor: 'rgba(0, 0, 0, 0.5)' // 阴影颜色&#125; itemStyle的emphasis是鼠标hover时候的高亮样式。上面的示例里是正常的样式下加阴影，但是可能更多的时候是hover的时候通过阴影突出。就需要如下的设置： 12345678itemStyle: &#123; emphasis: &#123; shadowBlur: 200,// 阴影的大小 shadowOffsetX: 0,// 阴影水平方向上的偏移 shadowOffsetY: 0,// 阴影垂直方向上的偏移 shadowColor: 'rgba(0, 0, 0, 0.5)' // 阴影颜色 &#125;&#125; 在鼠标悬浮到图形元素上时，一般会出现高亮的样式。默认情况下，高亮的样式是根据普通样式自动生成的。但是高亮的样式也可以自己定义，主要是通过 emphasis 属性来定制。emphsis 中的结构，和普通样式的结构相同,例如： 123456789101112131415161718192021222324252627option = &#123; series: &#123; type: 'scatter', // 普通样式。 itemStyle: &#123; // 点的颜色。 color: 'red' &#125;, label: &#123; show: true, // 标签的文字。 formatter: 'This is a normal label.' &#125;, // 高亮样式。 emphasis: &#123; itemStyle: &#123; // 高亮时点的颜色。 color: 'blue' &#125;, label: &#123; show: true, // 高亮时标签的文字。 formatter: 'This is a emphasis label.' &#125; &#125; &#125;&#125; 深色背景和浅色标签如果我们需要把整个主题改成深色主题，这就需要改背景色和文本颜色。 背景色是全局的，所以直接在 option下设置 backgroudColor 123setOption(&#123; backgroundColor: '#2c343c'&#125;) 文本的样式可以设置全局的 textStyle。 12345setOption(&#123; textStyle: &#123; color: 'rgba(255, 255, 255, 0.3)' &#125;&#125;) 也可以每个系列分别设置，每个系列的文本样式设置在 label.textStyle 12345label: &#123; textStyle: &#123; color: 'rgba(255, 255, 255, 0.3)' &#125;&#125; 饼图的话还要将标签的视觉引导线的颜色设为浅色12345labelLine: &#123; lineStyle: &#123; color: &apos;rgba(255, 255, 255, 0.3)&apos; &#125;&#125; 调色盘调色盘，可以在 option 中设置。它给定了一组颜色，图形、系列会自动从其中选择颜色。 可以设置全局的调色盘，也可以设置系列自己专属的调色盘。 12345678910111213141516option = &#123; // 全局调色盘。 color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83', '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'], series: [&#123; type: 'bar', // 此系列自己的调色盘。 color: ['#dd6b66','#759aa0','#e69d87','#8dc1a9','#ea7e53','#eedd78','#73a373','#73b9bc','#7289ab', '#91ca8c','#f49f42'], ... &#125;, &#123; type: 'pie', // 此系列自己的调色盘。 color: ['#37A2DA', '#32C5E9', '#67E0E3', '#9FE6B8', '#FFDB5C','#ff9f7f', '#fb7293', '#E062AE', '#E690D1', '#e7bcf3', '#9d96f5', '#8378EA', '#96BFFF'], ... &#125;]&#125; ECharts 中的样式设置注意点在 ECharts4 以前，高亮和普通样式的写法，是这样的： 12345678910111213141516171819202122232425262728293031option = &#123; series: &#123; type: 'scatter', itemStyle: &#123; // 普通样式。 normal: &#123; // 点的颜色。 color: 'red' &#125;, // 高亮样式。 emphasis: &#123; // 高亮时点的颜色。 color: 'blue' &#125; &#125;, label: &#123; // 普通样式。 normal: &#123; show: true, // 标签的文字。 formatter: 'This is a normal label.' &#125;, // 高亮样式。 emphasis: &#123; show: true, // 高亮时标签的文字。 formatter: 'This is a emphasis label.' &#125; &#125; &#125;&#125; 这种写法 仍然被兼容，但是，不再推荐。事实上，多数情况下，使用者只会配置普通状态下的样式，而使用默认的高亮样式。所以在 ECharts4 中，支持不写 normal 的配置方法（即本文开头的那种写法），使得配置项更扁平简单。 三、用到的ECharts的APIecharts 全局 echarts 对象，在 script 标签引入 echarts.js 文件后获得，或者在 AMD 环境中通过 require(‘echarts’) 获得 1、 echarts.init() 创建一个 ECharts 实例，返回 echartsInstance, 不能在单个容器上初始化多个 ECharts 实例。 参数 dom 实例容器，一般是一个具有高宽的div元素。 注：如果div是隐藏的，ECharts 可能会获取不到div的高宽导致初始化失败，这时候可以明确指定div的style.width和style.height，或者在div显示后手动调用 echartsInstance.resize 调整尺寸。 ECharts 3 中支持直接使用canvas元素作为容器，这样绘制完图表可以直接将 canvas 作为图片应用到其它地方，例如在 WebGL 中作为贴图，这跟使用 echartsInstance.getDataURL 生成图片链接相比可以支持图表的实时刷新。 theme 应用的主题。可以是一个主题的配置对象，也可以是使用已经通过 echarts.registerTheme 注册的主题名称。 opts 附加参数。有下面几个可选项： devicePixelRatio 设备像素比，默认取浏览器的值window.devicePixelRatio。 renderer 渲染器，支持 ‘canvas’ 或者 ‘svg’。参见 使用 Canvas 或者 SVG 渲染 。 width 可显式指定实例宽度，单位为像素。如果传入值为 null/undefined/‘auto’，则表示自动取 dom（实例容器）的宽度。 height 可显式指定实例高度，单位为像素。如果传入值为 null/undefined/‘auto’，则表示自动取 dom（实例容器）的高度。 echartsInstance通过 echarts.init 创建的实例。 2、 echartsInstance.setOption() 123(option: Object, notMerge?: boolean, lazyUpdate?: boolean)or(option: Object, opts?: Object) 设置图表实例的配置项以及数据，万能接口，所有参数和数据的修改都可以通过setOption完成，ECharts 会合并新的参数和数据，然后刷新图表。 注： ECharts 2.x 中的通过 addData , setSeries 方法设置配置项的方式将不再支持，在 ECharts 3 中统一使用setOption 调用方式： 1chart.setOption(option, notMerge, lazyUpdate); 或者12345chart.setOption(option, &#123; notMerge: ..., lazyUpdate: ..., silent: ...&#125;); 参数： option 图表的配置项和数据，具体见配置项手册。 notMerge 可选，是否不跟之前设置的option进行合并，默认为false，即合并。 lazyUpdate 可选，在设置完option后是否不立即更新图表，默认为false，即立即更新。 silent 可选，阻止调用 setOption 时抛出事件，默认为false，即抛出事件。 3、echartsInstance.clear() 清空当前实例，会移除实例中所有的组件和图表。清空后调用 getOption 方法返回一个{}空对象。 有时候图表会放在多个标签页里，多个图表共用一个容器，切换标签时，多个图表的配置项会合并出现在一起，如下图： 标签页下应该呈现的正确的图表效果： 对比就可以看出，标签页1切换到标签页2，图表1的数据以及线图的颜色的配置项被合并到图表2的配置项中；而切换到标签页2后再切回标签页1，图表2的配置项又被合并到图表1中，所以图表1的纵坐标数据出现了”%”。 该问题的解决方案有两种： (1) 设置图表实例的配置项以及数据时，将参数 notMerge的值设置为: true; notMerge : 是否不跟之前设置的option进行合并，默认为false，即合并, 设置为true，即不合并。 12345678910111213let queUse = echarts.init(document.getElementById('queUse'))// 绘制图表if (this.queCountTypeIndex === 0) &#123; queUse.setOption(this.opt1, &#123;notMerge: true&#125;) or queUse.setOption(this.opt1, true)&#125;if (this.queCountTypeIndex === 1) &#123; queUse.setOption(this.opt2, &#123;notMerge: true&#125;)&#125;window.addEventListener('resize', () =&gt; &#123; queUse.resize()&#125;) (2) 就是使用clear方法，每次切换标签页时先清空当前实例，再对该实例设置配置项以及数据。 12345678910111213let queUse = echarts.init(document.getElementById('queUse'))// 绘制图表if (this.queCountTypeIndex === 0) &#123; queUse.clear() queUse.setOption(this.opt1)&#125;if (this.queCountTypeIndex === 1) &#123; queUse.clear() queUse.setOption(this.opt2)&#125;window.addEventListener('resize', () =&gt; &#123; queUse.resize()&#125;) 4、 echartsInstance.resize() 改变图表尺寸，在容器大小发生改变时需要手动调用。 12345(opts?: &#123; width?: number|string, height?: number|string, silent?: boolean&#125;) =&gt; ECharts 参数 opts opts 可缺省。有下面几个可选项： width 可显式指定实例宽度，单位为像素。如果传入值为 null/undefined/‘auto’，则表示自动取 dom（实例容器）的宽度。 height 可显式指定实例高度，单位为像素。如果传入值为 null/undefined/‘auto’，则表示自动取 dom（实例容器）的高度。 silent 是否禁止抛出事件。默认为 false。 Tip: 有时候图表会放在多个标签页里，那些初始隐藏的标签在初始化图表的时候因为获取不到容器的实际高宽，可能会绘制失败，因此在切换到该标签页时需要手动调用 resize 方法获取正确的高宽并且刷新画布，或者在 opts 中显示指定图表高宽。 在vue组件中调用echartsInstance.resize()时，为了确保获取到容器的实际高宽，可以在 this.$nextTick()的回调函数中使用 resize 方法. events在 ECharts 中主要通过 on 方法添加事件处理函数。 在 ECharts 中事件分为两种类型，一种是用户鼠标操作点击，或者 hover 图表的图形时触发的事件，还有一种是用户在使用可以交互的组件后触发的行为事件，例如在切换图例开关时触发的 ‘legendselectchanged’ 事件（这里需要注意切换图例开关是不会触发’legendselected’事件的），数据区域缩放时触发的 ‘datazoom’ 事件等等。 鼠标事件包括’click’，’dblclick’，’mousedown’，’mouseup’，’mouseover’，’mouseout’，’globalout’，’contextmenu’。 123456// 使用指定的配置项和数据显示图表。myChart.setOption(option);// 处理点击事件并且跳转到相应的百度搜索页面myChart.on('click', function (params) &#123; window.open('https://www.baidu.com/s?wd=' + encodeURIComponent(params.name));&#125;); 所有的鼠标事件包含参数 params，这是一个包含点击图形的数据信息的对象，如下格式： { // 当前点击的图形元素所属的组件名称， // 其值如 ‘series’、’markLine’、’markPoint’、’timeLine’ 等。 componentType: string, // 系列类型。值可能为：’line’、’bar’、’pie’ 等。当 componentType 为 ‘series’ 时有意义。 seriesType: string, // 系列在传入的 option.series 中的 index。当 componentType 为 ‘series’ 时有意义。 seriesIndex: number, // 系列名称。当 componentType 为 ‘series’ 时有意义。 seriesName: string, // 数据名，类目名 name: string, // 数据在传入的 data 数组中的 index dataIndex: number, // 传入的原始数据项 data: Object, // sankey、graph 等图表同时含有 nodeData 和 edgeData 两种 data， // dataType 的值会是 ‘node’ 或者 ‘edge’，表示当前点击在 node 还是 edge 上。 // 其他大部分图表中只有一种 data，dataType 无意义。 dataType: string, // 传入的数据值 value: number|Array // 数据图形的颜色。当 componentType 为 ‘series’ 时有意义。 color: string} 如何区分鼠标点击到了哪里： 12345678910111213141516171819myChart.on('click', function (params) &#123; if (params.componentType === 'markPoint') &#123; // 点击到了 markPoint 上 if (params.seriesIndex === 5) &#123; // 点击到了 index 为 5 的 series 的 markPoint 上。 &#125; &#125; else if (params.componentType === 'series') &#123; if (params.seriesType === 'graph') &#123; if (params.dataType === 'edge') &#123; // 点击到了 graph 的 edge（边）上。 &#125; else &#123; // 点击到了 graph 的 node（节点）上。 &#125; &#125; &#125;&#125;);","categories":[],"tags":[]},{"title":"javascript执行机制","slug":"javascript执行机制","date":"2018-07-09T09:51:47.000Z","updated":"2020-12-23T03:11:07.907Z","comments":true,"path":"2018/07/09/javascript执行机制/","link":"","permalink":"http://yoursite.com/liumengjie2148.github.io/2018/07/09/javascript执行机制/","excerpt":"","text":"概览 js引擎是单线程的，如上图中，他负责维护任务队列，并通过Event Loop的机制按顺序把任务放入栈中执行。而图中的异步处理模块就是runtime提供的， 拥有和js引擎互不干扰的线程。 引擎： 解释并编译代码，让它变成能交给机器运行的代码。 runtime： 就是运行环境，它提供一些对外接口供js调用以跟外界打交道，比如，浏览器环境、Node.js环境。不同的runtime会停供不同的接口，比如，在Node.js环境中，我们可以通过require来引入模块，而在浏览器中，我们有window、DOM。 接下来介绍图中的： 栈和任务队列 栈 运行下面这段代码： 1234567891011121314function bar() &#123; console.log(1)&#125;function foo() &#123; console.log(2) bar();&#125;setTimeout(() =&gt; &#123; console.log(3)&#125;);foo(); 它在栈中的入栈、出栈过程，如下图： 任务队列 js中有两类任务队列：宏任务队列（macro tasks）和 微任务队列（micro tasks）。宏任务队列可以有多个，微任务队列只有一个。那么什么任务会分到那个队列呢？ 宏任务：script（全局任务），setTimeout，setInternal，setImmediate, I/O, UI rendering. 微任务：process.nextTick, Promise, Object.observer, MutationObserver. 我们上面讲到，当stack空的时候，就会从任务队列中，去任务来执行。共分3步： 取一个宏任务来执行，执行完毕后，执行下一步； 取一个微任务来执行，执行完毕后，再取一个微任务来执行，直到微任务队列为空，执行下一步； 更新UI渲染。 Event Loop 会无限循环执行上面3步，这就是Event Loop的主要控制逻辑。其中，第3步（更新UI渲染）会根据浏览器的逻辑，决定要不要马上执行更新，毕竟更新UI成本大，所以，一般都会比较长的时间间隔执行一次更新。 从执行步骤来看，我们发现微任务受到了特殊待遇！我们代码开始执行都是从script（全局任务）开始，所以，一旦我们的全局任务（属于宏任务）执行完，就马上执行完整个微任务队列。看个例子： 1234567891011121314151617181920212223242526272829303132console.log(&apos;script start&apos;);Promise.resolve().then(() =&gt; &#123; console.log(&apos;p 1&apos;);&#125;);setTimeout(() =&gt; &#123; console.log(&apos;setTimeout&apos;);&#125;, 0);var s = new Date();while(new Date() - s &lt; 50); // 阻塞50msPromise.resolve().then(() =&gt; &#123; console.log(&apos;p 2&apos;);&#125;);console.log(&apos;script end&apos;);/*** output ***/// one macro taskscript startscript end// all micro tasksp 1p 2// one macro task againsetTimeout 上面之所以加50ms的阻塞，是因为setTimeout的delayTime最少是4ms，为了避免认为setTimeout是因为4ms的延迟而在后面才被执行的，我们加了50ms的阻塞。在微任务中，process.nextTick是一个特殊的任务，它会被直接插入到微任务的队首（当然了，多个process.nextTick之间也是先入先出的），优先级最高。","categories":[],"tags":[]},{"title":"setTimeout小记","slug":"setTimeout小记","date":"2018-07-04T07:08:25.000Z","updated":"2018-07-04T08:56:11.679Z","comments":true,"path":"2018/07/04/setTimeout小记/","link":"","permalink":"http://yoursite.com/liumengjie2148.github.io/2018/07/04/setTimeout小记/","excerpt":"","text":"window setTimeout() 方法定义 setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。 语法 12setTimeout(code, milliseconds, params1, params2, ...)setTimeout(function, milliseconds, params1, params2, ...) 返回值： 返回一个ID（数字），可以将这个ID传递给clearTimeout()来取消执行setTimeout()方法。 实例 实例1： 用setTimeout() 方法实现 setInternal() 123456setTimeout(function()&#123; console.log(&apos;hello&apos;); setTimeout(function()&#123; console.log(&apos;hello&apos;); &#125;, 1000)&#125;, 1000) 实例2：下面的代码执行结果是？ 12345for(var i = 0; i&lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000)&#125; 执行结果： 输出5次5原因：setTimeout没有实现多线程，它背后的真相是这样的： JavaScript引擎是单线程运行的,浏览器无论在什么时候都只且只有一个线程在运行JavaScript程序。浏览器的内核是多线程的，它们在内核控制下相互配合以保持同步，一个浏览器至少实现三个常驻线程：JavaScript引擎线程，GUI渲染线程，浏览器事件触发线程。 JavaScript引擎是基于事件驱动单线程执行的，JavaScript引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JavaScript线程在运行JavaScript程序。 GUI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时,该线程就会执行。但需要注意，GUI渲染线程与JavaScript引擎是互斥的，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JavaScript引擎空闲时立即被执行。 事件触发线程，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JavaScript引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeout、也可来自浏览器内核的其他线程如鼠标点击、Ajax异步请求等，但由于JavaScript的单线程关系所有这些事件都得排队等待JavaScript引擎处理（当线程中没有执行任何同步代码的前提下才会执行异步代码）。 所以循环执行的时候，每次循环执行的时候，由于时间没到，所以setTimeout()方法里的函数不执行，添加到事件队列中，循环结束，i等于5，事件队列中存在5个事件函数，当时间到了的时候，会依次执行这5个函数，所以输出5次5。 实例3：如何让实例2中的代码输出每次循环时的i值？ 第一种方法：用setTimeout()方法的第3个参数将i值传递到匿名函数中 12345for(var i = 0; i &lt; 5; i++) &#123; setTimeout(function(count) &#123; console.log(count) &#125;, 1000, i)&#125; 第二种方法：用ES6的let关键字定义变量i 12345for(let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000)&#125; 解析：上面的代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是每次循环结束时的i值。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为JavaScript引擎内部会记住上一轮循环的值，初始化本轮变量i时，就在上一轮循环的基础上进行计算。","categories":[],"tags":[]},{"title":"Hello Hexo","slug":"hello-Hexo","date":"2018-07-04T07:06:59.034Z","updated":"2018-07-04T07:06:59.035Z","comments":true,"path":"2018/07/04/hello-Hexo/","link":"","permalink":"http://yoursite.com/liumengjie2148.github.io/2018/07/04/hello-Hexo/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"hexo+github搭建个人博客并部署到GitHub上","slug":"hexo-github搭建个人博客","date":"2018-05-11T07:00:28.000Z","updated":"2020-12-23T03:11:07.894Z","comments":true,"path":"2018/05/11/hexo-github搭建个人博客/","link":"","permalink":"http://yoursite.com/liumengjie2148.github.io/2018/05/11/hexo-github搭建个人博客/","excerpt":"","text":"准备步骤 安装Node.js和配置好Node.js环境; 安装Git和配置好Git环境; Github账户注册和新建项目 登陆github 点击这里新建一个仓储 按下面步骤操作，项目必须要遵守格式：账户名.github.io,并且需要勾选Initialize this repository with a README 然后这个仓储就创建好了，图中的地址一定要记好，将Hexo与Github page联系起来的时候会用到 安装hexo 输入npm install hexo -g，开始安装Hexo; 输入hexo -v，检查hexo是否安装成功. [hexo常用命令笔记] (https://segmentfault.com/a/1190000002632530) 初始化 hexo 在自己认为合适的地方创个文件夹: 例如 blog，然后通过命令行 cd blog 进入到该文件夹里面; 输入hexo init，初始化该文件夹; 输入npm install，安装所需要的组件; 输入hexo g，首次体验Hexo; 输入hexo s，开启服务器，访问[该网址] (http://localhost:4000/blog.github.io/.) ，正式体验Hexo。 问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入hexo server -p 端口号 来改变端口号 在 _config.yml 进行基础配置12345678910111213141516# Sitetitle: Hexo // 博客名称subtitle:description:keywords:author: John Doe // 作者language:timezone:theme: // 主题# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.com/blog.github.ioroot: /blog.github.io/permalink: :year/:month/:day/:title/permalink_defaults: 其中可以在 hexo Themes 浏览更多主题 以安装 BlueLake 主题为例： 安装主题在 blog 文件夹下打开cmd，输入命令：git clone https://github.com/iissnan/hexo-theme-nextthemes/next（next为主题名字），来获得更多主题 1git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake 安装主题渲染器BlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染 12npm install hexo-renderer-jade@0.3.0 --savenpm install hexo-renderer-stylus --save 启用主题打开根_config.yml配置文件，找到theme字段，将其值改为BlueLake(先确认主题文件夹名称是否为BlueLake) 更新主题今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。 12cd themes/BlueLakegit pull 将Hexo与Github page联系起来 设置Git的user name和email（如果是第一次的话） 输入cd ~/.ssh，检查是否有.ssh的文件夹; 输入ls，列出.ssh文件下的内容; 如果没有.ssh文件夹，输入ssh-keygen -t rsa -C &#39;929762930@qq.com&#39;，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\\Users\\Administrator.ssh）。 使用cd id_rsa.pub命令进入id_rsa.pub目录,再使用more id_rsa.pub命令查看密钥的内容; 登录Github，点击头像下的settings，添加ssh: 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去; 输入ssh -T git@github.com，测试添加ssh是否成功,如果看到Hi后面是你的github用户名，就说明成功了; 配置Deployment，在 blog 文件夹中，找到_config.yml文件，修改repo值（在末尾） 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git //github上创建好的仓储地址：格式如下 https://账户:密码@你的仓储地址，也就是上面要你记住的地址 repository: git@github.com:liumengjie2148/blog.github.io.git branch: master 新建一篇博客以及部署到github新建博客 新建一篇博客，在cmd执行命令：hexo new post &quot;博客名&quot;,这时候在文件夹_posts目录下将会看到已经创建的文件 部署到github 需要安装一个扩展：npm install hexo-deployer-git --save; 使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了[markdown语法]（http://www.markdown.cn/ ） 部署成功后访问你的地址：http://用户名.github.io, 那么将看到生成的文章","categories":[],"tags":[]}]}